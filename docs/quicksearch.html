<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"docs_scripts_fulltext-search-ui.js.html":{"id":"docs_scripts_fulltext-search-ui.js.html","title":"Source: docs/scripts/fulltext-search-ui.js","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Source: docs/scripts/fulltext-search-ui.js window.SearcherDisplay = (function($) { /** * This class provides support for displaying quick search text results to users. */ function SearcherDisplay() { } SearcherDisplay.prototype.init = function() { this._displayQuickSearch(); }; /** * This method creates the quick text search entry in navigation menu and wires all required events. */ SearcherDisplay.prototype._displayQuickSearch = function() { var quickSearch = $(document.createElement(\"iframe\")), body = $(\"body\"), self = this; quickSearch.attr(\"src\", \"quicksearch.html\"); quickSearch.css(\"width\", \"0px\"); quickSearch.css(\"height\", \"0px\"); body.append(quickSearch); $(window).on(\"message\", function(msg) { var msgData = msg.originalEvent.data; if (msgData.msgid != \"docstrap.quicksearch.done\") { return; } var results = msgData.results || []; self._displaySearchResults(results); }); function startSearch() { var searchTerms = $('#search-input').prop(\"value\"); if (searchTerms) { quickSearch[0].contentWindow.postMessage({ \"searchTerms\": searchTerms, \"msgid\": \"docstrap.quicksearch.start\" }, \"*\"); } } $('#search-input').on('keyup', function(evt) { if (evt.keyCode != 13) { return; } startSearch(); return false; }); $('#search-submit').on('click', function() { startSearch(); return false; }); }; /** * This method displays the quick text search results in a modal dialog. */ SearcherDisplay.prototype._displaySearchResults = function(results) { var resultsHolder = $($(\"#searchResults\").find(\".modal-body\")), fragment = document.createDocumentFragment(), resultsList = document.createElement(\"ul\"); resultsHolder.empty(); for (var idx = 0; idx &lt; results.length; idx++) { var result = results[idx], item = document.createElement(\"li\"), link = document.createElement(\"a\"); link.href = result.id; link.innerHTML = result.title; item.appendChild(link) resultsList.appendChild(item); } fragment.appendChild(resultsList); resultsHolder.append(fragment); $(\"#searchResults\").modal({\"show\": true}); }; return new SearcherDisplay(); })($); × Search results Close "},"src_Chord.js.html":{"id":"src_Chord.js.html","title":"Source: src/Chord.js","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Source: src/Chord.js import { Note } from '.' /** * represents a Chord. */ export class Chord { /** * * @param {Note} root * @param {Note} third * @param {Note} fifth * @param {Note} note4(optional) * @param {Note} note5(optional) */ constructor(root, third, fifth, note4 = null, duration = 'q') { this.root = root this.duration = duration this.isChord = true if (this.root.index &gt; third.index) this.third = new Note(third.note, third.octave + 1, third.duration, third.instrument) else this.third = third if (this.root.index &gt; fifth.index) this.fifth = new Note(fifth.note, fifth.octave + 1, fifth.duration, fifth.instrument) else this.fifth = fifth if (this.root.getInterval(4).isEqual(this.third)) { if (this.root.getInterval(7).isEqual(this.fifth)) { if (note4 == null) { this.type = \"Major\" this.symbol = \"\" } else { this.note4 = note4 if (this.root.getInterval(5).isEqual(this.note4)) { this.type = \"Added Fourth\" this.symbol = \"add4\" } else if (this.root.getInterval(9).isEqual(this.note4)) { if (note5 == null) { this.note5 = note5 this.type = \"Sixth\" this.symbol = \"6\" } else { if (this.root.getInterval(14).isEqual(this.note5)) { this.type = \"Six Nine\" this.symbol = \"6/9\" } else { this.isChord = false } } } else if (this.root.getInterval(11).isEqual(this.note4)) { if (note5 == null) { this.type = \"Major 7th\" this.symbol = \"Maj7\" } else { this.note5 = note5 if (this.root.getInterval(14).isEqual(note5)) { this.type = \"Major Ninth\" this.symbol = \"Maj9\" } else if (this.root.getInterval(17).isEqual(note5)) { this.type = \"Major Eleventh\" this.symbol = \"Maj11\" } else if (this.root.getInterval(21).isEqual(note5)) { this.type = \"Major Thirteenth\" this.symbol = \"Maj13\" } else if (this.root.getInterval(18).isEqual(note5)) { this.type = \"Major Seven Sharp Eleventh\" this.symbol = \"Maj7#11\" } else { this.isChord = false } } } else if (this.root.getInterval(10).isEqual(this.note4)) { if (note5 == null) { this.type = \"Seventh\" this.symbol = \"7\" } else { this.note5 = note5 if (this.root.getInterval(14).isEqual(note5)) { this.type = \"Ninth\" this.symbol = \"9\" } else if (this.root.getInterval(17).isEqual(note5)) { this.type = \"Eleventh\" this.symbol = \"11\" } else if (this.root.getInterval(21).isEqual(note5)) { this.type = \"Thirteenth\" this.symbol = \"13\" } } } } } else if (this.root.getInterval(6).isEqual(this.fifth)) { this.type = \"Major Flat Fifth\" this.symbol = \"b5\" } else if (this.root.getInterval(8).isEqual(this.fifth)) { this.type = \"Major Augmented Fifth\" this.symbol = \"aug\" } } else if (this.root.getInterval(3).isEqual(this.third)) { if (this.root.getInterval(7).isEqual(this.fifth)) { if (note4 == null) { this.type = \"Minor\" this.symbol = \"m\" } else { this.note4 = note4 if (this.root.getInterval(5).isEqual(this.note4)) { this.type = \"Minor Added Fourth\" this.symbol = \"madd4\" } else if (this.root.getInterval(9).isEqual(this.note4)) { if (note5 == null) { this.note5 = note5 this.type = \"Minor Sixth\" this.symbol = \"m6\" } else { if (this.root.getInterval(14).isEqual(this.note5)) { this.type = \"Minor Six Nine\" this.symbol = \"m6/9\" } else { this.isChord = false } } } else if (this.root.getInterval(10).isEqual(this.note4)) { if (note5 == null) { this.type = \"Minor Seventh\" this.symbol = \"m7\" } else { this.note5 = note5 if (this.root.getInterval(14).isEqual(note5)) { this.type = \"Minor Ninth\" this.symbol = \"m9\" } else if (this.root.getInterval(17).isEqual(note5)) { this.type = \"Minor Eleventh\" this.symbol = \"m11\" } else if (this.root.getInterval(21).isEqual(note5)) { this.type = \"Minor Thirteenth\" this.symbol = \"m13\" } else { this.isChord = false } } } } } else if (this.root.getInterval(6).isEqual(this.fifth)) { if (this.note4 == null) { this.type = \"Diminished\" this.symbol = \"dim\" } else { this.note4 = note4 if (this.root.getInterval(9).isEqual(this.note4)) { this.type = \"Diminished Seventh\" this.symbol = \"dim7\" } } } } if (this.type == undefined) { this.root.lang = \"#\" == this.root.lang ? \"b\" : \"#\" if (this.root.getInterval(4).isEqual(this.third)) { if (this.root.getInterval(7).isEqual(this.fifth)) { if (note4 == null) { this.type = \"Major\" this.symbol = \"\" } else { this.note4 = note4 if (this.root.getInterval(5).isEqual(this.note4)) { this.type = \"Added Fourth\" this.symbol = \"add4\" } else if (this.root.getInterval(9).isEqual(this.note4)) { if (note5 == null) { this.note5 = note5 this.type = \"Sixth\" this.symbol = \"6\" } else { if (this.root.getInterval(14).isEqual(this.note5)) { this.type = \"Six Nine\" this.symbol = \"6/9\" } else { this.isChord = false } } } else if (this.root.getInterval(11).isEqual(this.note4)) { if (note5 == null) { this.type = \"Major 7th\" this.symbol = \"Maj7\" } else { this.note5 = note5 if (this.root.getInterval(14).isEqual(note5)) { this.type = \"Major Ninth\" this.symbol = \"Maj9\" } else if (this.root.getInterval(17).isEqual(note5)) { this.type = \"Major Eleventh\" this.symbol = \"Maj11\" } else if (this.root.getInterval(21).isEqual(note5)) { this.type = \"Major Thirteenth\" this.symbol = \"Maj13\" } else if (this.root.getInterval(18).isEqual(note5)) { this.type = \"Major Seven Sharp Eleventh\" this.symbol = \"Maj7#11\" } else { this.isChord = false } } } else if (this.root.getInterval(10).isEqual(this.note4)) { if (note5 == null) { this.type = \"Seventh\" this.symbol = \"7\" } else { this.note5 = note5 if (this.root.getInterval(14).isEqual(note5)) { this.type = \"Ninth\" this.symbol = \"9\" } else if (this.root.getInterval(17).isEqual(note5)) { this.type = \"Eleventh\" this.symbol = \"11\" } else if (this.root.getInterval(21).isEqual(note5)) { this.type = \"Thirteenth\" this.symbol = \"13\" } } } } } else if (this.root.getInterval(6).isEqual(this.fifth)) { this.type = \"Major Flat Fifth\" this.symbol = \"b5\" } else if (this.root.getInterval(8).isEqual(this.fifth)) { this.type = \"Major Augmented Fifth\" this.symbol = \"aug\" } } else if (this.root.getInterval(3).isEqual(this.third)) { if (this.root.getInterval(7).isEqual(this.fifth)) { if (note4 == null) { this.type = \"Minor\" this.symbol = \"m\" } else { this.note4 = note4 if (this.root.getInterval(5).isEqual(this.note4)) { this.type = \"Minor Added Fourth\" this.symbol = \"madd4\" } else if (this.root.getInterval(9).isEqual(this.note4)) { if (note5 == null) { this.note5 = note5 this.type = \"Minor Sixth\" this.symbol = \"m6\" } else { if (this.root.getInterval(14).isEqual(this.note5)) { this.type = \"Minor Six Nine\" this.symbol = \"m6/9\" } else { this.isChord = false } } } else if (this.root.getInterval(10).isEqual(this.note4)) { if (note5 == null) { this.type = \"Minor Seventh\" this.symbol = \"m7\" } else { this.note5 = note5 if (this.root.getInterval(14).isEqual(note5)) { this.type = \"Minor Ninth\" this.symbol = \"m9\" } else if (this.root.getInterval(17).isEqual(note5)) { this.type = \"Minor Eleventh\" this.symbol = \"m11\" } else if (this.root.getInterval(21).isEqual(note5)) { this.type = \"Minor Thirteenth\" this.symbol = \"m13\" } else { this.isChord = false } } } } } else if (this.root.getInterval(6).isEqual(this.fifth)) { if (this.note4 == null) { this.type = \"Diminished\" this.symbol = \"dim\" } else { this.note4 = note4 if (this.root.getInterval(9).isEqual(this.note4)) { this.type = \"Diminished Seventh\" this.symbol = \"dim7\" } } } } } if (this.note4 == null) this.chord_notes = [this.root, this.third, this.fifth] else { if (this.note5 == null) this.chord_notes = [this.root, this.third, this.fifth, this.note4] else this.chord_notes = [this.root, this.third, this.fifth, this.note4, this.note5] } } /** * play all the notes in the chord as a melody. */ playMelody() { let self = this for (let i = 0; i &lt; this.chord_notes.length; i++) { setTimeout(function timer() { self.chord_notes[i].play() }, i * 500) } } /** * play all the notes in the chord as a harmony. */ play() { for (let i = 0; i &lt; this.chord_notes.length; i++) this.chord_notes[i].play() } /** * Transforms the chord into its root position. */ rootPosition() { this.third._octave = this.root._octave this.fifth._octave = this.root._octave return this } /** * Transforms the chord into its 1st-inversion. */ inversionFirst() { this.root._octave = this.root._octave + 1 return this } /** * Transforms the chord into its 2st-inversion. */ inversionSecond() { this.root.octave = this.root.octave + 1 this.third.octave = this.third.octave + 1 return this } /** * returns string of the name of the chord and all the notes it contains. */ toString() { if (this.symbol == undefined) { if (this.note4 == null) return this.root.note + \" {\" + this.root + \", \" + this.third + \", \" + this.fifth + \"}\" else if (this.note5 == null) return this.root.note + \" {\" + this.root + \", \" + this.third + \", \" + this.fifth + \", \" + this.note4 + \"}\" return this.root.note + \" {\" + this.root + \", \" + this.third + \", \" + this.fifth + \", \" + this.note4 + \", \" + this.note5 + \"}\" } else if (this.note4 == null) return this.root.note + this.symbol + \" {\" + this.root + \", \" + this.third + \", \" + this.fifth + \"}\" else if (this.note5 == null) return this.root.note + this.symbol + \" {\" + this.root + \", \" + this.third + \", \" + this.fifth + \", \" + this.note4 + \"}\" return this.root.note + this.symbol + \" {\" + this.root + \", \" + this.third + \", \" + this.fifth + \", \" + this.note4 + \", \" + this.note5 + \"}\" } newDuration(duration) { return new Chord(this.root, this.third, this.fifth, this.note4, this.note5, duration) } } × Search results Close "},"src_Scale.js.html":{"id":"src_Scale.js.html","title":"Source: src/Scale.js","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Source: src/Scale.js import {Note, Chord, MusicalPattern} from '.' /** * represents a Diatonic Scale(a scale that consists of 7 notes), * @extends MusicalPattern */ export class DiatonicScale extends MusicalPattern { /** * * @param {Note/String} tonic Root of the Scale * @param {Array} pattern Intervals for the other notes(from the tonic). */ constructor(tonic, pattern) { super(tonic, pattern) this.chords = [] this.show = false for(let i in this.notes.slice(0,7)) this.chords.push(new Chord(this.notes[i], this.notes[(parseInt(i)+2)%7], this.notes[(parseInt(i)+4)%7])) } /** * returns the x chord of the scale. * @param {number} chord Chord Number */ getChord(chord) { return this.chords[chord-1] != undefined ? this.chords[chord-1] : null } /** * returns array with all the chords in the scale. */ getChords(){ return this.chords } } × Search results Close "},"src_MusicalPattern.js.html":{"id":"src_MusicalPattern.js.html","title":"Source: src/MusicalPattern.js","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Source: src/MusicalPattern.js import {Note, piano} from '.' /** * Represents a musical pattern. */ export class MusicalPattern { /** * @param {String/Note} tonic * @param {Array} pattern *@constructor */ constructor(tonic, pattern) { if (tonic instanceof Note) this.tonic = tonic else this.tonic = new Note(tonic) this.pattern = pattern // this.notes = [this.tonic] this._notes = [] for (let j of pattern) { const interval = this.tonic.getInterval(j) this._notes.push(piano.note(interval.note + interval.octave + interval.duration)) } this._notes.push(piano.note(tonic.note + (tonic.octave + 1) + tonic.duration)) } /** * returns array that contains all the notes in the pattern. */ get notes() { return this._notes } /** * returns a string of all the notes in the pattern */ toString() { let str = \"\" for (let i = 0; i &lt; this.notes.length - 1; ++i) str += this.notes[i] + \", \" str += this.notes[this.notes.length - 1] return str } /** * returns the interval inside the pattern * for example - if the pattern is C Major scale, * than getInterval(1) wiil return D. * @param {number} interval */ getInterval(interval) { let counter = 0 for (let i = 0; i &lt; interval; i++) counter += this.pattern[i] return this.tonic.getInterval(counter) } /** * load all the sound files of the notes in the pattern. */ loadSound() { for (let n of this.notes) n.loadSound() } /** * play all the notes in the pattern one after the other. */ play() { let self = this for (let i = 0; i &lt; this.notes.length; i++) { setTimeout(function timer() { self.notes[i].play() }, i * 500) } } } × Search results Close "},"src_Key.js.html":{"id":"src_Key.js.html","title":"Source: src/Key.js","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Source: src/Key.js import {Note, Chord, DiatonicScale} from '.' /** * represents a Musical Key that is based on a specific Diatonic Scale., * @extends DiatonicScale */ export class Key extends DiatonicScale{ constructor(tonic, pattern){ super(tonic, pattern) } addChordProgression(chords, ){ } } export default Key × Search results Close "},"src_Measure.js.html":{"id":"src_Measure.js.html","title":"Source: src/Measure.js","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Source: src/Measure.js import {Note, Rhythm, Chord, note_durations} from \".\" import { isArray } from 'util' /** * Measure - represents a single measure as part of a musical piece. * @class */ export class Measure { /** * * @param {Array} data An array which contains notes or chords */ constructor(data = [], max_duration = 0) { this._data = data this.max_duration = max_duration this._duration = 0 this.updateDuration() } /** * Array of all the notes in the measure */ get data() { return this._data } /** * Assign new notes to measure */ set data(data) { this._data = data } /** * Returns a new array with the same notes. */ getData() { const data = new Array() for (const i of this.data) data.push(i) return data } /** * get the duration */ get duration() { return this._duration } /** * set the duration */ set duration(duration) { this._duration = duration } /** * Change notes somewhere inside a measure * @param {Number} index The index where the notes will be changed * @param {Array/Note} new_notes Notes to change to */ mutate(i, new_notes) { const newData = JSON.parse(JSON.stringify(this.data)) newData[i] = new_notes return new Measure(newData) } /** * Add data to the end of the measure * @param {Note/Chord} new_notes */ addNotes(new_notes) { this.data.push(new_notes) } updateDuration() { this.duration = 0 let valid = 0 for (const notes of this.data) { if (notes instanceof Note || notes instanceof Chord) { this.duration += note_durations[notes.duration] } else if (isArray(notes)) { let min_duration = notes[0].duration notes.forEach((note) =&gt; { min_duration = min_duration &lt; note_durations[note.duration] ? min_duration : note_durations[note.duration] }) this.duration += min_duration } if (this.duration &lt;= this.max_duration || this.max_duration === 0) valid++ else break } this.data = this.data.slice(0, valid) } toString() { let string = \"Measure: { \" for (const i of this.data) if (i instanceof Note || i instanceof Chord) string += i.toString() + \", \" else { string += '[ ' for (const j of i) string += j + ', ' string += '] ' } string += '} ' return string } } export default Measure × Search results Close "},"src_Note.js.html":{"id":"src_Note.js.html","title":"Source: src/Note.js","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Source: src/Note.js import path from 'path' import {firstToUpper, notes, circle_of_fourths, semitone} from '.' import { Howl } from 'howler' const sounds = new Map() /** * Represents a single musical note. * @class */ export class Note { /** * @param {String} note Musical Note * @param {number} octave Note Octave * @param {String} duration Note duration * @param {String} instrument Piano/Guitar/etc... * @constructor */ constructor(note = \"A\", octave = 3, duration = 'q', instrument = 'Piano') { note = firstToUpper(note) note = !notes[\"#\"].includes(note) &amp;&amp; !notes.b.includes(note) ? \"A\" : note this._octave = octave this._duration = duration this._lang = circle_of_fourths.includes(note) ? \"b\" : \"#\" this._index = notes[this.lang].indexOf(note) this._note = note this.instrument = \"Piano\" Note.setSound(this) } // gets a note and creates it's active Howl player in the notes hash-table so we can play it static setSound(note) { const key = note.instrument + notes['b'][notes[note.lang].indexOf(note.note)] + note._octave if (!sounds.has(key)) { const filePath = '/static/Media/' + note.instrument + '/' + 'FF_' + notes['b'][notes[note.lang].indexOf(note.note)] + note._octave + '.mp3' sounds.set(key, new Howl({ src: [filePath] })) } } /** * returns the note alphabet representation as a string. * @type {String} * @readonly */ get note() { return this._note } /** * get octave of note. * @type {Number} * @readonly */ get octave() { return this._octave } /** * get the duration of a note * @type {String} * @readonly */ get duration() { return this._duration } /** * get the frequancy of a note. * @type {Number} * @readonly */ get frequency() { let octave_interval = this._octave - 4 //calculate octave difference return Math.pow(semitone, this.index - 9 + octave_interval * 12) * 440 } // whether the note is a part of flats or sharps. get lang() { return this._lang } // set whether note is in '#' or 'b' family set lang(l){ this._lang = (l == '#' || l == 'b') ? l : this._lang } // returns the index of the note from the 12 notes (C, Db, etc...) get index() { return this._index } /** * returns a clone of the note(new instance). */ clone() { return (new Note(this.note, this.octave, this.duration, this.instrument)) } /** * gets a number as interval and returns a new instance of a note * which is constructed by the musical interval formula. * for example, if the note is a 'C' in octave 3, * calling the function with the number 4(which is a major third) will return * a Note instance with the musical note 'E' in octave 3 with the same instrument. * @param {number} interval Musical Interval */ getInterval(interval) { if(interval &gt;= 0){ const oct_diff = (this.index + interval) / 12 return new Note(notes[this.lang][(this.index + interval) % 12], parseInt(this.octave) + parseInt(oct_diff), this.duration, this.instrument) } const oct_diff = this.index + interval &lt; 0 ? Math.floor((this.index + interval) / 12) : 0 return new Note(notes[this.lang][Math.abs((this.index + (12 + (interval%12)))%12)], parseInt(this.octave) + parseInt(oct_diff), this.duration, this.instrument) } // getMajorChord() { // return new Chord(this, this.getInterval(4), this.getInterval(7)) // } getMajorScale() { let scale = [this.note] for (let i of major_scale) { scale.push(this.getInterval(i)) } return toString(scale) } /** * Returns the note name and octave. * @example * 'C3' */ toString() { return this.note + this.octave } /** * Check if 2 notes are equal in letter and octave. * @param {Note} note */ isEqual(note) { if (this.note == note.note &amp;&amp; this.octave == note.octave) return true return false } /** * Returns string of the note fields formatted as an object. */ print() { return '{Note: ' + this.note + ', Octave: ' + this._octave + '}' } /** * Play the note. */ play() { if (sounds.get(this.instrument + notes['b'][notes[this.lang].indexOf(this.note)] + this._octave) instanceof Howl) sounds.get(this.instrument + notes['b'][notes[this.lang].indexOf(this.note)] + this._octave).play() else console.log('Sound not loaded! please make sure you load with x.loadSound()') } } × Search results Close "},"src_Piece.js.html":{"id":"src_Piece.js.html","title":"Source: src/Piece.js","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Source: src/Piece.js import {Note, Rhythm, Sequence, Measure, Chord, note_durations} from '.' import { isArray } from 'util' export class Piece { constructor(BPM, time_signature, data) { this._BPM = BPM this._time_signature = time_signature this.rhythm = Rhythm.getRhythm(BPM, time_signature) if (data) this._data = data else this._data = [] this.init() } init(){ this.duration = 0 this.playable_data = new Array() for (const i of this.data) { if (i instanceof Measure || i instanceof Sequence) { for (const j of i.getData()) { this.playable_data.push(j) this.duration += note_durations[j.duration] } } else { this.playable_data.push(i) this.duration += note_durations[i.duration] } } this.length = this.calculateLength() } get data() { return this._data } set data(data) { this._data = data this.init() } /** * get the duration */ get duration() { return this._duration } /** * set the duration */ set duration(duration) { this._duration = duration } get BPM() { return this._BPM } set BPM(BPM) { this._BPM = BPM this.rhythm.updateBPM(BPM) this.length = this.calculateLength() } calculateLength() { this.length = 0 this.playable_data.forEach(data =&gt; { if (data instanceof Note || data instanceof Chord) { this.length += 60 / this.BPM * note_durations[data.duration] * this.rhythm.beats_per_measure } else if (isArray(data)) { let min_duration = note_durations[data.duration] data.forEach((note) =&gt; { min_duration = min_duration &lt; note_durations[note.duration] ? min_duration : note_durations[note.duration] }) this.length += 60 / this.BPM * min_duration * this.rhythm.beats_per_measure } }) return this.length } play() { this.rhythm.addNotes(this.playable_data) this.rhythm.toggle() } pushToData(new_data) { this.data.push(new_data) } toString() { let string = \"Piece: { \" for (let i of this.data) string += i.toString() + ', ' string += '} ' return string } } export default Piece × Search results Close "},"src_Rhythm.js.html":{"id":"src_Rhythm.js.html","title":"Source: src/Rhythm.js","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Source: src/Rhythm.js import {Note, Chord, note_durations} from '.' import { isArray } from 'util' let rhythm function scheduler() { // while there are notes that will need to play before the next interval, schedule them and advance the pointer. while (rhythm.next_interval &lt; rhythm.audioCtx.currentTime + rhythm.scheduleAheadTime) { if (rhythm.next_note &gt;= rhythm.data_with_time.length - 1){ for(let i=0;i&lt;rhythm.calculate_ahead;i++) rhythm.scheduleNote() } rhythm.nextNote() } rhythm.timerID = setTimeout(scheduler, rhythm.lookahead) } /** * Creates a rhythm instance which holds bpm and time signature information. * @class */ export class Rhythm { /** * Create a new instance of rhythm. * @param {Number} bpm Speed of the rhythm in beats per minute * @param {Array} time_signature the number of notes per measure as an array [number_of_notes, type_of_notes] */ constructor(bpm, time_signature) { this.data = null // the Sounds that will be played this.dataKeeper = null //will hold the music to reload it when it reaches the end this.reload_data = false //variable to dictate whether data needs to be reloaded or not this.metronome_sound = new Howl({ src: ['/static/Media/Metronome/1.wav'] }) // for cross browser compatibility AudioContext = window.AudioContext || window.webkitAudioContext //web audio api instance this.audioCtx = new AudioContext() this.min_interval = 1 / 16 //the interval at which the schedualer will be called and data will be able to be played. this.next_interval = 0.0 //the time at which the next interval will be called updating with currentTime this.calculate_ahead = 10 // how many notes to calculate precise time for ahead this.data_with_time = [] //Array which contains objects with sounds and time properties this.next_note = 0 //the next note which needs to be played this.next_note_to_schedule = 0 //the next note which needs to be scheduled and inserted to data_with_time this.overall_time = 0 //the overall time that passes when scheduling the notes(sum of start time and every duration of every note scheduled) this.metronome = false //metronome playing or not this.timerID = null //the timerID of the setInterval this.lookahead = 10 // How frequently to call scheduling function (in milliseconds) this.scheduleAheadTime = 0.1 // How far ahead to schedule audio (sec) this.seconds_per_beat = 60 / bpm //beats per second - tempo this.current_beat = 1 //current beat this.lastNoteDrawn = 3 this.bpm = bpm this.beats_per_measure = time_signature[0] this.beat_duration = time_signature[1] this.isPlaying = false this.beat_check = 0 this.loop = true } /** * returns a instance of rhythm to avoid creating more than one(a singleton) * @param {Number} bpm Speed of the rhythm in beats per minute * @param {Array} time_signature the number of notes per measure as an array [number_of_notes, type_of_notes] * @static */ static getRhythm(bpm = 80, time_signature = [4, 4]) { if (rhythm) return rhythm rhythm = new Rhythm(bpm, time_signature) return rhythm } /** * Schedual a note to be played at a specific time */ scheduleNote() { // push the note on the queue, even if we're not playing. if (this.data[this.next_note_to_schedule]) { this.scheduleNoteHelper(this.data[this.next_note_to_schedule]) this.next_note_to_schedule++ } else { this.next_note_to_schedule = 0 } } /** * Helps the SchedualNote check what kind of data is dealt with at the moment and handles it. * @param {Array/Note/Chord} data */ scheduleNoteHelper(data) { if (data instanceof Note || data instanceof Chord) { this.data_with_time.push({ sounds: [data], time: this.overall_time }) this.overall_time += 60 / this.bpm * note_durations[data.duration] * this.beats_per_measure } else if (isArray(data)) { let min_duration = note_durations[data.duration] data.forEach((note) =&gt; { min_duration = min_duration &lt; note_durations[note.duration] ? min_duration : note_durations[note.duration] }) this.data_with_time.push({ sounds: data, time: this.overall_time }) this.overall_time += 60 / this.bpm * min_duration * this.beats_per_measure } } playSounds() { for (const i of this.data_with_time[this.next_note].sounds) { // console.log(i.toString()) i.play() } } /** * Advances to the next note and updates the beat */ nextNote() { this.next_interval += this.seconds_per_beat * this.min_interval // Advance the beat number, wrap to zero this.beat_check += this.seconds_per_beat * this.min_interval if (this.prev_beat_time + this.seconds_per_beat &lt;= this.audioCtx.currentTime) { // console.log(this.prev_beat_time - this.start_time) if (this.metronome) this.metronome_sound.play() // console.log(audioCtx.currentTime - this.start_time) this.beat_check = 0 this.current_beat++ if (this.current_beat === this.beats_per_measure + 1) { this.current_beat = 1 } this.prev_beat_time += this.seconds_per_beat } if (this.data_with_time[this.next_note]) if (this.data_with_time[this.next_note].time &lt;= this.audioCtx.currentTime) { // console.log(this.data_with_time[this.next_note].time - this.start_time) this.playSounds() this.next_note++ } } draw() { let drawNote = rhythm.lastNoteDrawn rhythm.currentTime = rhythm.audioCtx.currentTime // We only need to draw if the note has moved. if (rhythm.lastNoteDrawn != drawNote) { rhythm.lastNoteDrawn = drawNote } // set up to draw again requestAnimationFrame(rhythm.draw) } getBeat() { return this.current_beat } toggle(index = 0) { rhythm = this this.isPlaying = !this.isPlaying if (this.isPlaying) { // start playing // check if context is in suspended state (autoplay policy) if (this.audioCtx.state === 'suspended') { this.audioCtx.resume() } this.start_time = this.audioCtx.currentTime this.overall_time = this.audioCtx.currentTime this.prev_beat_time = this.audioCtx.currentTime this.data_with_time.length = 0 this.next_note = index this.current_beat = 1 this.next_note_to_schedule = index scheduler() // kick off scheduling requestAnimationFrame(this.draw) // start the drawing loop. } else { clearTimeout(this.timerID) } } addNotes(data) { this.data = data } toggleMetronome() { if (rhythm) rhythm.metronome = !rhythm.metronome } updateBPM(bpm) { this.bpm = bpm this.seconds_per_beat = 60 / bpm if(this.isPlaying == true){ this.toggle() this.toggle() } } } × Search results Close "},"src_RhythmOld.js.html":{"id":"src_RhythmOld.js.html","title":"Source: src/RhythmOld.js","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Source: src/RhythmOld.js import {Note, Chord, note_durations} from '.' import { isArray } from 'util' var rhythm // for cross browser compatibility const AudioContext = window.AudioContext || window.webkitAudioContext //web audio api instance const audioCtx = new AudioContext() let min_interval = 1 / 16 //the interval at which the schedualer will be called and data will be able to be played. let next_interval = 0.0 //the time at which the next interval will be called updating with currentTime let next_note_time = 0.0 // when the next note is due. function scheduler() { // while there are notes that will need to play before the next interval, schedule them and advance the pointer. while (next_interval &lt; audioCtx.currentTime + rhythm.scheduleAheadTime) { rhythm.nextNote() } rhythm.timerID = setTimeout(scheduler, rhythm.lookahead) } /** * Creates a rhythm instance which holds bpm and time signature information. * @class */ export class Rhythm { constructor(bpm, time_signature) { this.data = null // the Sounds that will be played this.dataKeeper = null //will hold the music to reload it when it reaches the end this.reload_data = false //variable to dictate whether data needs to be reloaded or not this.metronome_sound = new Howl({ src: ['/static/Media/Metronome/1.wav'] }) this.metronome = false //metronome playing or not this.timerID = null //the timerID of the setInterval this.lookahead = 60 / this.bpm * min_interval // How frequently to call scheduling function (in milliseconds) this.scheduleAheadTime = 0.1 // How far ahead to schedule audio (sec) this.current_beat = 1 //current beat this.notesInQueue = [] this.next_note = 1 this.lastNoteDrawn = 3 this.bpm = bpm this.beats_per_measure = time_signature[0] this.beat_duration = time_signature[1] this.isPlaying = false this.beat_check = 0 this.loop = true } static getRhythm() { if (rhythm) return rhythm rhythm = new Rhythm(60, [4, 4]) return rhythm } scheduleNote() { // push the note on the queue, even if we're not playing. if (this.data.length) { if (this.data[0]) { this.scheduleNoteHelper(this.data[0]) this.data.splice(0, 1) } } else { this.reload_data = true } } scheduleNoteHelper(data) { if (data instanceof Note || data instanceof Chord) { this.next_note = this.data.length ? note_durations[data.duration] : null console.log(data.toString()) data.play() } else if (isArray(data)) { let min_duration = note_durations[data.duration], playNow = [], curr_notes_playing = \"\" for (const n of data) { min_duration = min_duration &lt; note_durations[n.duration] ? min_duration : note_durations[n.duration] playNow.push(n) curr_notes_playing += n.toString() + ' ' } for (const n of playNow) n.play() console.log(curr_notes_playing) this.next_note = this.data.length ? min_duration : null } } nextNote() { var secondsPerBeat = 60 / this.bpm // tempo next_interval += secondsPerBeat * min_interval // Advance the beat number, wrap to zero this.beat_check += secondsPerBeat * min_interval if (this.beat_check &gt;= secondsPerBeat) { if (this.metronome) this.metronome_sound.play() this.beat_check = 0 this.current_beat++ if (this.current_beat === this.beats_per_measure + 1) { this.current_beat = 1 } } if (next_note_time &lt;= audioCtx.currentTime) { this.scheduleNote() next_note_time += secondsPerBeat * this.next_note * this.beats_per_measure // Add beat duration to last beat time } } draw() { let drawNote = rhythm.lastNoteDrawn rhythm.currentTime = audioCtx.currentTime // while (rhythm.notesInQueue.length &amp;&amp; rhythm.notesInQueue[0].time &lt; rhythm.currentTime) { // drawNote = rhythm.notesInQueue[0].note // rhythm.notesInQueue.splice(0, 1) // remove note from queue // } // We only need to draw if the note has moved. if (rhythm.lastNoteDrawn != drawNote) { rhythm.lastNoteDrawn = drawNote } // set up to draw again requestAnimationFrame(rhythm.draw) } getBeat() { return this.current_beat } toggle() { rhythm = this this.start_time = audioCtx.currentTime if (this.reload_data) { this.reload_data = false this.data = this.dataKeeper } this.isPlaying = !this.isPlaying if (this.isPlaying) { // start playing // check if context is in suspended state (autoplay policy) if (audioCtx.state === 'suspended') { audioCtx.resume() } this.current_beat = 0 this.next_note = audioCtx.currentTime next_note_time = audioCtx.currentTime scheduler() // kick off scheduling requestAnimationFrame(this.draw) // start the drawing loop. } else { clearTimeout(this.timerID) } } addNotes(data) { this.data = data this.dataKeeper = JSON.parse(JSON.stringify(data)) } toggleMetronome() { if (rhythm) rhythm.metronome = !rhythm.metronome } } × Search results Close "},"src_Sequence.js.html":{"id":"src_Sequence.js.html","title":"Source: src/Sequence.js","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Source: src/Sequence.js export class Sequence { constructor(measures = []) { this._measures = measures this._duration = 0 this._measures.forEach(meas =&gt; { this._duration += meas.duration }) } get measures() { return this._measures } set measures(measures) { this._measures = measures } /** * get the duration */ get duration() { return this._duration } /** * set the duration */ set duration(duration) { this._duration = duration } getData() { const data = new Array() for (const i of this.measures) for (const j of i.data) data.push(j) return data } length() { return this._measures.length; } addMeasure(measure) { this.measures.push(measure) } toString() { let string = \"Sequence: { \" for (let i of this.measures) string += i.toString() + ', ' string += '} ' return string } } × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Classes Classes Chord DiatonicScale Key Measure MusicalPattern Note Rhythm Rhythm × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Note-Art JS Musical Project By Sean Dvir A Work in progress!Music is a highly versatile art that originates in nature, and has been taken up by mankind as a way of expression and also as an art.Now, it's going to be taken up by machines as well.-This project aims to create a library that implements all of music theory(in all it's forms) in code, then create AI that will use that theory, math, and neuroscience to compose music in different styles and genres.It will also be used to create multiple tools for people to practice, learn, enjoy and compose. Installation# go to project folder npm install note-art “Everything is determined … by forces over which we have nocontrol. It is determined for the insects as well as for the star.Human beings, vegetables, or cosmic dust – we all dance to amysterious tune, intoned in the distance by an invisible piper.”– Albert Einstein × Search results Close "},"Chord.html":{"id":"Chord.html","title":"Class: Chord","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Class: Chord Chord represents a Chord. new Chord(root, third, fifth, note4(optional), note5(optional)) Parameters: Name Type Description root Note third Note fifth Note note4(optional) Note note5(optional) Note Source: src/Chord.js, line 7 Methods inversionFirst() Transforms the chord into its 1st-inversion. Source: src/Chord.js, line 325 inversionSecond() Transforms the chord into its 2st-inversion. Source: src/Chord.js, line 332 play() play all the notes in the chord as a harmony. Source: src/Chord.js, line 310 playMelody() play all the notes in the chord as a melody. Source: src/Chord.js, line 299 rootPosition() Transforms the chord into its root position. Source: src/Chord.js, line 317 toString() returns string of the name of the chord and all the notes it contains. Source: src/Chord.js, line 340 × Search results Close "},"DiatonicScale.html":{"id":"DiatonicScale.html","title":"Class: DiatonicScale","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Class: DiatonicScale DiatonicScale represents a Diatonic Scale(a scale that consists of 7 notes), new DiatonicScale(tonic, pattern) Parameters: Name Type Description tonic Note/String Root of the Scale pattern Array Intervals for the other notes(from the tonic). Source: src/Scale.js, line 6 Extends MusicalPattern Members notes returns array that contains all the notes in the pattern. Inherited From: MusicalPattern#notes Source: src/MusicalPattern.js, line 28 Methods getChord(chord) returns the x chord of the scale. Parameters: Name Type Description chord number Chord Number Source: src/Scale.js, line 23 getChords() returns array with all the chords in the scale. Source: src/Scale.js, line 29 getInterval(interval) returns the interval inside the patternfor example - if the pattern is C Major scale,than getInterval(1) wiil return D. Parameters: Name Type Description interval number Inherited From: MusicalPattern#getInterval Source: src/MusicalPattern.js, line 46 loadSound() load all the sound files of the notes in the pattern. Inherited From: MusicalPattern#loadSound Source: src/MusicalPattern.js, line 55 play() play all the notes in the pattern one after the other. Inherited From: MusicalPattern#play Source: src/MusicalPattern.js, line 62 toString() returns a string of all the notes in the pattern Inherited From: MusicalPattern#toString Source: src/MusicalPattern.js, line 34 × Search results Close "},"Key.html":{"id":"Key.html","title":"Class: Key","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Class: Key Key represents a Musical Key that is based on a specific Diatonic Scale., new Key() Source: src/Key.js, line 6 Extends DiatonicScale Methods getChord(chord) returns the x chord of the scale. Parameters: Name Type Description chord number Chord Number Inherited From: DiatonicScale#getChord Source: src/Scale.js, line 23 getChords() returns array with all the chords in the scale. Inherited From: DiatonicScale#getChords Source: src/Scale.js, line 29 × Search results Close "},"Measure.html":{"id":"Measure.html","title":"Class: Measure","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Class: Measure Measure Measure - represents a single measure as part of a musical piece. new Measure(data) Parameters: Name Type Description data Array An array which contains notes or chords Source: src/Measure.js, line 9 Members data Assign new notes to measure Source: src/Measure.js, line 29 data Array of all the notes in the measure Source: src/Measure.js, line 23 duration get the duration Source: src/Measure.js, line 44 duration set the duration Source: src/Measure.js, line 50 Methods addNotes(new_notes) Add data to the end of the measure Parameters: Name Type Description new_notes Note/Chord Source: src/Measure.js, line 67 getData() Returns a new array with the same notes. Source: src/Measure.js, line 35 mutate(index, new_notes) Change notes somewhere inside a measure Parameters: Name Type Description index Number The index where the notes will be changed new_notes Array/Note Notes to change to Source: src/Measure.js, line 58 × Search results Close "},"MusicalPattern.html":{"id":"MusicalPattern.html","title":"Class: MusicalPattern","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Class: MusicalPattern MusicalPattern Represents a musical pattern. new MusicalPattern(tonic, pattern) Parameters: Name Type Description tonic String/Note pattern Array Source: src/MusicalPattern.js, line 5 Members notes returns array that contains all the notes in the pattern. Source: src/MusicalPattern.js, line 28 Methods getInterval(interval) returns the interval inside the patternfor example - if the pattern is C Major scale,than getInterval(1) wiil return D. Parameters: Name Type Description interval number Source: src/MusicalPattern.js, line 46 loadSound() load all the sound files of the notes in the pattern. Source: src/MusicalPattern.js, line 55 play() play all the notes in the pattern one after the other. Source: src/MusicalPattern.js, line 62 toString() returns a string of all the notes in the pattern Source: src/MusicalPattern.js, line 34 × Search results Close "},"Note.html":{"id":"Note.html","title":"Class: Note","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Class: Note Note Represents a single musical note. new Note(note, octave, duration, instrument) Parameters: Name Type Default Description note String A Musical Note octave number 3 Note Octave duration String q Note duration instrument String Piano Piano/Guitar/etc... Source: src/Note.js, line 13 Members &lt;readonly&gt; duration :String get the duration of a note Type: String Source: src/Note.js, line 64 &lt;readonly&gt; frequency :Number get the frequancy of a note. Type: Number Source: src/Note.js, line 72 &lt;readonly&gt; note :String returns the note alphabet representation as a string. Type: String Source: src/Note.js, line 48 &lt;readonly&gt; octave :Number get octave of note. Type: Number Source: src/Note.js, line 56 Methods clone() returns a clone of the note(new instance). Source: src/Note.js, line 94 getInterval(interval) gets a number as interval and returns a new instance of a notewhich is constructed by the musical interval formula.for example, if the note is a 'C' in octave 3,calling the function with the number 4(which is a major third) will returna Note instance with the musical note 'E' in octave 3 with the same instrument. Parameters: Name Type Description interval number Musical Interval Source: src/Note.js, line 105 isEqual(note) Check if 2 notes are equal in letter and octave. Parameters: Name Type Description note Note Source: src/Note.js, line 135 play() Play the note. Source: src/Note.js, line 149 print() Returns string of the note fields formatted as an object. Source: src/Note.js, line 143 toString() Returns the note name and octave. Source: src/Note.js, line 128 Example 'C3' × Search results Close "},"Rhythm.html":{"id":"Rhythm.html","title":"Class: Rhythm","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Class: Rhythm Rhythm Creates a rhythm instance which holds bpm and time signature information. new Rhythm(bpm, time_signature) Create a new instance of rhythm. Parameters: Name Type Description bpm Number Speed of the rhythm in beats per minute time_signature Array the number of notes per measure as an array [number_of_notes, type_of_notes] Source: src/Rhythm.js, line 22 Methods &lt;static&gt; getRhythm(bpm, time_signature) returns a instance of rhythm to avoid creating more than one(a singleton) Parameters: Name Type Default Description bpm Number 80 Speed of the rhythm in beats per minute time_signature Array the number of notes per measure as an array [number_of_notes, type_of_notes] Source: src/Rhythm.js, line 74 nextNote() Advances to the next note and updates the beat Source: src/Rhythm.js, line 124 scheduleNote() Schedual a note to be played at a specific time Source: src/Rhythm.js, line 83 scheduleNoteHelper(data) Helps the SchedualNote check what kind of data is dealt with at the moment and handles it. Parameters: Name Type Description data Array/Note/Chord Source: src/Rhythm.js, line 96 Class: Rhythm Rhythm Creates a rhythm instance which holds bpm and time signature information. new Rhythm() Source: src/RhythmOld.js, line 24 Methods &lt;static&gt; getRhythm(bpm, time_signature) returns a instance of rhythm to avoid creating more than one(a singleton) Parameters: Name Type Default Description bpm Number 80 Speed of the rhythm in beats per minute time_signature Array the number of notes per measure as an array [number_of_notes, type_of_notes] Source: src/Rhythm.js, line 74 nextNote() Advances to the next note and updates the beat Source: src/Rhythm.js, line 124 scheduleNote() Schedual a note to be played at a specific time Source: src/Rhythm.js, line 83 scheduleNoteHelper(data) Helps the SchedualNote check what kind of data is dealt with at the moment and handles it. Parameters: Name Type Description data Array/Note/Chord Source: src/Rhythm.js, line 96 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
