<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"docs_scripts_fulltext-search-ui.js.html":{"id":"docs_scripts_fulltext-search-ui.js.html","title":"Source: docs/scripts/fulltext-search-ui.js","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Source: docs/scripts/fulltext-search-ui.js window.SearcherDisplay = (function($) { /** * This class provides support for displaying quick search text results to users. */ function SearcherDisplay() { } SearcherDisplay.prototype.init = function() { this._displayQuickSearch(); }; /** * This method creates the quick text search entry in navigation menu and wires all required events. */ SearcherDisplay.prototype._displayQuickSearch = function() { var quickSearch = $(document.createElement(\"iframe\")), body = $(\"body\"), self = this; quickSearch.attr(\"src\", \"quicksearch.html\"); quickSearch.css(\"width\", \"0px\"); quickSearch.css(\"height\", \"0px\"); body.append(quickSearch); $(window).on(\"message\", function(msg) { var msgData = msg.originalEvent.data; if (msgData.msgid != \"docstrap.quicksearch.done\") { return; } var results = msgData.results || []; self._displaySearchResults(results); }); function startSearch() { var searchTerms = $('#search-input').prop(\"value\"); if (searchTerms) { quickSearch[0].contentWindow.postMessage({ \"searchTerms\": searchTerms, \"msgid\": \"docstrap.quicksearch.start\" }, \"*\"); } } $('#search-input').on('keyup', function(evt) { if (evt.keyCode != 13) { return; } startSearch(); return false; }); $('#search-submit').on('click', function() { startSearch(); return false; }); }; /** * This method displays the quick text search results in a modal dialog. */ SearcherDisplay.prototype._displaySearchResults = function(results) { var resultsHolder = $($(\"#searchResults\").find(\".modal-body\")), fragment = document.createDocumentFragment(), resultsList = document.createElement(\"ul\"); resultsHolder.empty(); for (var idx = 0; idx &lt; results.length; idx++) { var result = results[idx], item = document.createElement(\"li\"), link = document.createElement(\"a\"); link.href = result.id; link.innerHTML = result.title; item.appendChild(link) resultsList.appendChild(item); } fragment.appendChild(resultsList); resultsHolder.append(fragment); $(\"#searchResults\").modal({\"show\": true}); }; return new SearcherDisplay(); })($); × Search results Close "},"src_Chord.js.html":{"id":"src_Chord.js.html","title":"Source: src/Chord.js","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Source: src/Chord.js import { Note, } from '.' /** * represents a Chord. */ export class Chord { /** * * @param {Note} root * @param {Note} third * @param {Note} fifth * @param {Note} note4(optional) * @param duration */ constructor(root, third, fifth, note4 = null, duration = 'q') { this._duration = duration this.isChord = true if (!(root instanceof Note)) { root = new Note(root) third = new Note(third) fifth = new Note(fifth) note4 = note4 ? new Note(note4) : null } if (root.index &gt; third.index) { third = new Note(third.note, root.octave + 1, third.duration, third.instrument) } else { third = new Note(third.note, root.octave, third.duration, third.instrument) } if (root.index &gt; fifth.index) { fifth = new Note(fifth.note, root.octave + 1, fifth.duration, fifth.instrument) } else { fifth = new Note(fifth.note, root.octave, third.duration, third.instrument) } if (root.getInterval(4).note === third.note) { if (root.getInterval(7).note === fifth.note) { if (note4 == null) { this.type = 'Major' this.symbol = '' } else { if (root.getInterval(5).note === note4.note) { this.type = 'Added Fourth' this.symbol = 'add4' } else if (root.getInterval(9).note === note4.note) { this.type = 'Sixth' this.symbol = '6' } else if (root.getInterval(11).note === note4.note) { this.type = 'Major 7th' this.symbol = 'Maj7' } else if (root.getInterval(10).note === note4.note) { this.type = 'Seventh' this.symbol = '7' } } } else if (root.getInterval(6).note === fifth.note) { this.type = 'Major Flat Fifth' this.symbol = 'b5' } else if (root.getInterval(8).note === fifth.note) { this.type = 'Major Augmented Fifth' this.symbol = 'aug' } } else if (root.getInterval(3).note === third.note) { if (root.getInterval(7).note === fifth.note) { if (note4 == null) { this.type = 'Minor' this.symbol = 'm' } else { if (root.getInterval(5).note === note4.note) { this.type = 'Minor Added Fourth' this.symbol = 'madd4' } else if (root.getInterval(9).note === note4.note) { this.type = 'Minor Sixth' this.symbol = 'm6' } else if (root.getInterval(10).note === note4.note) { this.type = 'Minor Seventh' this.symbol = 'm7' } } } else if (root.getInterval(6).note === fifth.note) { if (note4 == null) { this.type = 'Diminished' this.symbol = 'dim' } else { if (root.getInterval(9).note === note4.note) { this.type = 'Diminished Seventh' this.symbol = 'dim7' } } } } if (this.type === undefined) { this.type = 'Unknown' this.symbol = '' this.isChord = false } this.chord_notes = [root, third, fifth] if (note4) { this.chord_notes.push(note4) } } /** * The index of the root. * @type {Number} * @readonly */ static get ROOT() {return 0} /** * The index of the third. * @type {Number} * @readonly */ static get THIRD() {return 1} /** * The index of the fifth. * @type {Number} * @readonly */ static get FIFTH() {return 2} /** * The index of the fourth note. * @type {Number} * @readonly */ static get NOTE4() {return 3} /** * The root of the chord as Note * @returns {Note} * @readonly */ get root() { return this.chord_notes[Chord.ROOT] } /** * The third of the chord as Note * @returns {Note} * @readonly */ get third() { return this.chord_notes[Chord.THIRD]} /** * The fifth of the chord as Note * @returns {Note} * @readonly */ get fifth() {return this.chord_notes[Chord.FIFTH]} /** * The fourth note of the chord as Note * @returns {Note} * @readonly */ get note4() {return this.chord_notes[Chord.NOTE4]} /** * The duration of the chord as String * @returns {String} * @readonly */ get duration() { return this._duration } /** * play all the notes in the chord as a melody. */ playMelody() { let self = this for (let i = 0; i &lt; this.chord_notes.length; i++) { setTimeout(function timer() { self.chord_notes[i].play() }, i * 500) } } /** * play all the notes in the chord as a harmony. */ play() { for (let i = 0; i &lt; this.chord_notes.length; i++) this.chord_notes[i].play() } /** * Transforms the chord into its root position. */ rootPosition() { // TODO } /** * Transforms the chord into its 1st-inversion. */ inversionFirst() { //TODO } /** * Transforms the chord into its 2st-inversion. */ inversionSecond() { //TODO } /** * returns string of the name of the chord and all the notes it contains. */ toString() { if (this.symbol == undefined) { if (this.note4 == null) { return this.root.note + ' {' + this.root + ', ' + this.third + ', ' + this.fifth + '}' } else if (this.note5 == null) { return this.root.note + ' {' + this.root + ', ' + this.third + ', ' + this.fifth + ', ' + this.note4 + '}' } return this.root.note + ' {' + this.root + ', ' + this.third + ', ' + this.fifth + ', ' + this.note4 + ', ' + this.note5 + '}' } else if (this.note4 == null) { return this.root.note + this.symbol + ' {' + this.root + ', ' + this.third + ', ' + this.fifth + '}' } else if (this.note5 == null) { return this.root.note + this.symbol + ' {' + this.root + ', ' + this.third + ', ' + this.fifth + ', ' + this.note4 + '}' } return this.root.note + this.symbol + ' {' + this.root + ', ' + this.third + ', ' + this.fifth + ', ' + this.note4 + ', ' + this.note5 + '}' } newDuration(duration) { return new Chord(this.root, this.third, this.fifth, this.note4, this.note5, duration) } } × Search results Close "},"src_Scale.js.html":{"id":"src_Scale.js.html","title":"Source: src/Scale.js","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Source: src/Scale.js import {Note, Chord, MusicalPattern} from '.' /** * represents a Diatonic Scale(a scale that consists of 7 notes), * @extends MusicalPattern */ export class DiatonicScale extends MusicalPattern { /** * * @param {Note/String} tonic Root of the Scale * @param {Array} pattern Intervals for the other notes(from the tonic). */ constructor(tonic, pattern) { super(tonic, pattern) this.chords = [] this.show = false for (let i in this.notes.slice(0, 7)) this.chords.push(new Chord(this.notes[i], this.notes[(parseInt(i) + 2) % 7], this.notes[(parseInt(i) + 4) % 7])) } /** * returns the x chord of the scale. * @param {number} chord Chord Number */ getChord(chord) { return this.chords[chord - 1] != undefined ? this.chords[chord - 1] : null } /** * returns array with all the chords in the scale. */ getChords() { return this.chords } } × Search results Close "},"src_MusicalPattern.js.html":{"id":"src_MusicalPattern.js.html","title":"Source: src/MusicalPattern.js","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Source: src/MusicalPattern.js import {Note, piano} from '.' /** * Represents a musical pattern. */ export class MusicalPattern { /** * @param {String/Note} tonic * @param {Array} pattern *@constructor */ constructor(tonic, pattern) { if (tonic instanceof Note) this.tonic = tonic else this.tonic = new Note(tonic) this.pattern = pattern // this.notes = [this.tonic] this._notes = [] for (let j of pattern) this._notes.push(this.tonic.getInterval(j)) this._notes.push(this.tonic.getInterval(12)) } /** * returns array that contains all the notes in the pattern. */ get notes() { return this._notes } /** * returns a string of all the notes in the pattern */ toString() { let str = \"\" for (let i = 0; i &lt; this.notes.length - 1; ++i) str += this.notes[i] + \", \" str += this.notes[this.notes.length - 1] return str } /** * returns the interval inside the pattern * for example - if the pattern is C Major scale, * than getInterval(1) wiil return D. * @param {number} interval */ getInterval(interval) { let counter = 0 for (let i = 0; i &lt; interval; i++) counter += this.pattern[i] return this.tonic.getInterval(counter) } /** * load all the sound files of the notes in the pattern. */ loadSound() { for (let n of this.notes) n.loadSound() } /** * play all the notes in the pattern one after the other. */ play() { let self = this for (let i = 0; i &lt; this.notes.length; i++) { setTimeout(function timer() { self.notes[i].play() }, i * 500) } } } × Search results Close "},"src_Key.js.html":{"id":"src_Key.js.html","title":"Source: src/Key.js","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Source: src/Key.js import {Note, Chord, DiatonicScale} from '.' /** * represents a Musical Key that is based on a specific Diatonic Scale., * @extends DiatonicScale */ export class Key extends DiatonicScale{ constructor(tonic, pattern){ super(tonic, pattern) } addChordProgression(chords, ){ } } export default Key × Search results Close "},"src_Measure.js.html":{"id":"src_Measure.js.html","title":"Source: src/Measure.js","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Source: src/Measure.js import {Note, Rhythm, Chord, note_durations} from \".\" import { isArray } from 'util' /** * Measure - represents a single measure as part of a musical piece. * @class */ export class Measure { /** * * @param {Array} data An array which contains notes or chords */ constructor(data = [], max_duration = 0) { this._data = data this.max_duration = max_duration this._duration = 0 this.updateDuration() } /** * Array of all the notes in the measure */ get data() { return this._data } /** * Assign new notes to measure */ set data(data) { this._data = data } /** * Returns a new array with the same notes. */ getData() { const data = new Array() for (const i of this.data) data.push(i) return data } /** * get the duration */ get duration() { return this._duration } /** * set the duration */ set duration(duration) { this._duration = duration } /** * Change notes somewhere inside a measure * @param {Number} index The index where the notes will be changed * @param {Array/Note} new_notes Notes to change to */ mutate(i, new_notes) { const newData = JSON.parse(JSON.stringify(this.data)) newData[i] = new_notes return new Measure(newData) } /** * Add data to the end of the measure * @param {Note/Chord} new_notes */ addNotes(new_notes) { this.data.push(new_notes) } updateDuration() { this.duration = 0 let valid = 0 for (const notes of this.data) { if (notes instanceof Note || notes instanceof Chord) { this.duration += note_durations[notes.duration] } else if (isArray(notes)) { let min_duration = notes[0].duration notes.forEach((note) =&gt; { min_duration = min_duration &lt; note_durations[note.duration] ? min_duration : note_durations[note.duration] }) this.duration += min_duration } if (this.duration &lt;= this.max_duration || this.max_duration === 0) valid++ else break } this.data = this.data.slice(0, valid) } toString() { let string = \"Measure: { \" for (const i of this.data) if (i instanceof Note || i instanceof Chord) string += i.toString() + \", \" else { string += '[ ' for (const j of i) string += j + ', ' string += '] ' } string += '} ' return string } } export default Measure × Search results Close "},"src_Note.js.html":{"id":"src_Note.js.html","title":"Source: src/Note.js","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Source: src/Note.js import path from 'path' import {firstToUpper, notes, circle_of_fourths, semitone} from '.' import { Howl } from 'howler' const sounds = new Map() /** * Represents a single musical note. * @class */ export class Note { /** * @param {String} note Musical Note * @param {number} octave Note Octave * @param {String} duration Note duration * @param {String} instrument Piano/Guitar/etc... * @constructor */ constructor(note = \"A\", octave = 3, duration = 'q', instrument = 'Piano') { note = firstToUpper(note) note = !notes[\"#\"].includes(note) &amp;&amp; !notes.b.includes(note) ? \"A\" : note this._octave = octave this._duration = duration this._lang = circle_of_fourths.includes(note) ? \"b\" : \"#\" this._index = notes[this.lang].indexOf(note) this._note = note this.instrument = instrument Note.setSound(this) } // gets a note and creates it's active Howl player in the notes hash-table so we can play it static setSound(note) { const key = note.instrument + notes['b'][notes[note.lang].indexOf(note.note)] + note._octave if (!sounds.has(key)) { const filePath = '/static/Media/' + note.instrument + '/' + 'FF_' + notes['b'][notes[note.lang].indexOf(note.note)] + note._octave + '.mp3' sounds.set(key, new Howl({ src: [filePath] })) } } /** * returns the note alphabet representation as a string. * @type {String} * @readonly */ get note() { return this._note } /** * get octave of note. * @type {Number} * @readonly */ get octave() { return this._octave } /** * get the duration of a note * @type {String} * @readonly */ get duration() { return this._duration } /** * get the frequancy of a note. * @type {Number} * @readonly */ get frequency() { let octave_interval = this._octave - 4 //calculate octave difference return Math.pow(semitone, this.index - 9 + octave_interval * 12) * 440 } // whether the note is a part of circle of fourths or fifths. get lang() { return this._lang } // set whether note is in '#' or 'b' family set lang(l){ this._lang = (l == '#' || l == 'b') ? l : this._lang } // returns the index of the note from the 12 notes (C, Db, etc...) get index() { return this._index } /** * returns a clone of the note(new instance). */ clone() { return (new Note(this.note, this.octave, this.duration, this.instrument)) } /** * gets a number as interval and returns a new instance of a note * which is constructed by the musical interval formula. * for example, if the note is a 'C' in octave 3, * calling the function with the number 4(which is a major third) will return * a Note instance with the musical note 'E' in octave 3 with the same instrument. * @param {number} interval Musical Interval */ getInterval(interval) { if(interval &gt;= 0){ const oct_diff = (this.index + interval) / 12 return new Note(notes[this.lang][(this.index + interval) % 12], this.octave + parseInt(oct_diff), this.duration, this.instrument) } const oct_diff = this.index + interval &lt; 0 ? Math.floor((this.index + interval) / 12) : 0 return new Note(notes[this.lang][Math.abs((this.index + (12 + (interval%12)))%12)], parseInt(this.octave) + parseInt(oct_diff), this.duration, this.instrument) } // getMajorChord() { // return new Chord(this, this.getInterval(4), this.getInterval(7)) // } getMajorScale() { let scale = [this.note] for (let i of major_scale) { scale.push(this.getInterval(i)) } return toString(scale) } /** * Returns the note name and octave. * @example * 'C3' */ toString() { return this.note + this.octave } /** * Check if 2 notes are equal in letter and octave. * @param {Note} note */ isEqual(note) { if (this.note === note.note &amp;&amp; this.octave === note.octave) return true return false } /** * Returns string of the note fields formatted as an object. */ print() { return '{Note: ' + this.note + ', Octave: ' + this._octave + '}' } /** * Play the note. */ play() { if (sounds.get(this.instrument + notes['b'][notes[this.lang].indexOf(this.note)] + this._octave) instanceof Howl) sounds.get(this.instrument + notes['b'][notes[this.lang].indexOf(this.note)] + this._octave).play() else console.log('Sound not loaded! please make sure you load with x.loadSound()') } } × Search results Close "},"src_Piece.js.html":{"id":"src_Piece.js.html","title":"Source: src/Piece.js","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Source: src/Piece.js import {Note, Rhythm, Sequence, Measure, Chord, note_durations} from '.' import { isArray } from 'util' export class Piece { constructor(BPM, time_signature, data) { this._BPM = BPM this._time_signature = time_signature this.rhythm = Rhythm.getRhythm(BPM, time_signature) if (data) this._data = data else this._data = [] this.init() } init(){ this.duration = 0 this.playable_data = new Array() for (const i of this.data) { if (i instanceof Measure || i instanceof Sequence) { for (const j of i.getData()) { this.playable_data.push(j) this.duration += note_durations[j.duration] } } else { this.playable_data.push(i) this.duration += note_durations[i.duration] } } this.length = this.calculateLength() } get data() { return this._data } set data(data) { this._data = data this.init() } /** * get the duration */ get duration() { return this._duration } /** * set the duration */ set duration(duration) { this._duration = duration } get BPM() { return this._BPM } set BPM(BPM) { this._BPM = BPM this.rhythm.updateBPM(BPM) this.length = this.calculateLength() } calculateLength() { this.length = 0 this.playable_data.forEach(data =&gt; { if (data instanceof Note || data instanceof Chord) { this.length += 60 / this.BPM * note_durations[data.duration] * this.rhythm.beats_per_measure } else if (isArray(data)) { let min_duration = note_durations[data.duration] data.forEach((note) =&gt; { min_duration = min_duration &lt; note_durations[note.duration] ? min_duration : note_durations[note.duration] }) this.length += 60 / this.BPM * min_duration * this.rhythm.beats_per_measure } }) return this.length } play() { this.rhythm.addNotes(this.playable_data) this.rhythm.toggle() } pushToData(new_data) { this.data.push(new_data) } toString() { let string = \"Piece: { \" for (let i of this.data) string += i.toString() + ', ' string += '} ' return string } } export default Piece × Search results Close "},"src_RhythmOld.js.html":{"id":"src_RhythmOld.js.html","title":"Source: src/RhythmOld.js","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Source: src/RhythmOld.js import {Note, Chord, note_durations} from '.' import { isArray } from 'util' var rhythm // for cross browser compatibility const AudioContext = window.AudioContext || window.webkitAudioContext //web audio api instance const audioCtx = new AudioContext() let min_interval = 1 / 16 //the interval at which the schedualer will be called and data will be able to be played. let next_interval = 0.0 //the time at which the next interval will be called updating with currentTime let next_note_time = 0.0 // when the next note is due. function scheduler() { // while there are notes that will need to play before the next interval, schedule them and advance the pointer. while (next_interval &lt; audioCtx.currentTime + rhythm.scheduleAheadTime) { rhythm.nextNote() } rhythm.timerID = setTimeout(scheduler, rhythm.lookahead) } /** * Creates a rhythm instance which holds bpm and time signature information. * @class */ export class Rhythm { constructor(bpm, time_signature) { this.data = null // the Sounds that will be played this.dataKeeper = null //will hold the music to reload it when it reaches the end this.reload_data = false //variable to dictate whether data needs to be reloaded or not this.metronome_sound = new Howl({ src: ['/static/Media/Metronome/1.wav'] }) this.metronome = false //metronome playing or not this.timerID = null //the timerID of the setInterval this.lookahead = 60 / this.bpm * min_interval // How frequently to call scheduling function (in milliseconds) this.scheduleAheadTime = 0.1 // How far ahead to schedule audio (sec) this.current_beat = 1 //current beat this.notesInQueue = [] this.next_note = 1 this.lastNoteDrawn = 3 this.bpm = bpm this.beats_per_measure = time_signature[0] this.beat_duration = time_signature[1] this.isPlaying = false this.beat_check = 0 this.loop = true } static getRhythm() { if (rhythm) return rhythm rhythm = new Rhythm(60, [4, 4]) return rhythm } scheduleNote() { // push the note on the queue, even if we're not playing. if (this.data.length) { if (this.data[0]) { this.scheduleNoteHelper(this.data[0]) this.data.splice(0, 1) } } else { this.reload_data = true } } scheduleNoteHelper(data) { if (data instanceof Note || data instanceof Chord) { this.next_note = this.data.length ? note_durations[data.duration] : null console.log(data.toString()) data.play() } else if (isArray(data)) { let min_duration = note_durations[data.duration], playNow = [], curr_notes_playing = \"\" for (const n of data) { min_duration = min_duration &lt; note_durations[n.duration] ? min_duration : note_durations[n.duration] playNow.push(n) curr_notes_playing += n.toString() + ' ' } for (const n of playNow) n.play() console.log(curr_notes_playing) this.next_note = this.data.length ? min_duration : null } } nextNote() { var secondsPerBeat = 60 / this.bpm // tempo next_interval += secondsPerBeat * min_interval // Advance the beat number, wrap to zero this.beat_check += secondsPerBeat * min_interval if (this.beat_check &gt;= secondsPerBeat) { if (this.metronome) this.metronome_sound.play() this.beat_check = 0 this.current_beat++ if (this.current_beat === this.beats_per_measure + 1) { this.current_beat = 1 } } if (next_note_time &lt;= audioCtx.currentTime) { this.scheduleNote() next_note_time += secondsPerBeat * this.next_note * this.beats_per_measure // Add beat duration to last beat time } } draw() { let drawNote = rhythm.lastNoteDrawn rhythm.currentTime = audioCtx.currentTime // while (rhythm.notesInQueue.length &amp;&amp; rhythm.notesInQueue[0].time &lt; rhythm.currentTime) { // drawNote = rhythm.notesInQueue[0].note // rhythm.notesInQueue.splice(0, 1) // remove note from queue // } // We only need to draw if the note has moved. if (rhythm.lastNoteDrawn != drawNote) { rhythm.lastNoteDrawn = drawNote } // set up to draw again requestAnimationFrame(rhythm.draw) } getBeat() { return this.current_beat } toggle() { rhythm = this this.start_time = audioCtx.currentTime if (this.reload_data) { this.reload_data = false this.data = this.dataKeeper } this.isPlaying = !this.isPlaying if (this.isPlaying) { // start playing // check if context is in suspended state (autoplay policy) if (audioCtx.state === 'suspended') { audioCtx.resume() } this.current_beat = 0 this.next_note = audioCtx.currentTime next_note_time = audioCtx.currentTime scheduler() // kick off scheduling requestAnimationFrame(this.draw) // start the drawing loop. } else { clearTimeout(this.timerID) } } addNotes(data) { this.data = data this.dataKeeper = JSON.parse(JSON.stringify(data)) } toggleMetronome() { if (rhythm) rhythm.metronome = !rhythm.metronome } } × Search results Close "},"src_Rhythm.js.html":{"id":"src_Rhythm.js.html","title":"Source: src/Rhythm.js","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Source: src/Rhythm.js import {Note, Chord, note_durations} from '.' import { isArray } from 'util' let rhythm function scheduler() { // while there are notes that will need to play before the next interval, schedule them and advance the pointer. while (rhythm.next_interval &lt; rhythm.audioCtx.currentTime + rhythm.scheduleAheadTime) { if (rhythm.next_note &gt;= rhythm.data_with_time.length - 1){ for(let i=0;i&lt;rhythm.calculate_ahead;i++) rhythm.scheduleNote() } rhythm.nextNote() } rhythm.timerID = setTimeout(scheduler, rhythm.lookahead) } /** * Creates a rhythm instance which holds bpm and time signature information. * @class */ export class Rhythm { /** * Create a new instance of rhythm. * @param {Number} bpm Speed of the rhythm in beats per minute * @param {Array} time_signature the number of notes per measure as an array [number_of_notes, type_of_notes] */ constructor(bpm, time_signature) { this.data = null // the Sounds that will be played this.dataKeeper = null //will hold the music to reload it when it reaches the end this.reload_data = false //variable to dictate whether data needs to be reloaded or not this.metronome_sound = new Howl({ src: ['/static/Media/Metronome/1.wav'] }) // for cross browser compatibility AudioContext = window.AudioContext || window.webkitAudioContext //web audio api instance this.audioCtx = new AudioContext() this.min_interval = 1 / 16 //the interval at which the schedualer will be called and data will be able to be played. this.next_interval = 0.0 //the time at which the next interval will be called updating with currentTime this.calculate_ahead = 10 // how many notes to calculate precise time for ahead this.data_with_time = [] //Array which contains objects with sounds and time properties this.next_note = 0 //the next note which needs to be played this.next_note_to_schedule = 0 //the next note which needs to be scheduled and inserted to data_with_time this.overall_time = 0 //the overall time that passes when scheduling the notes(sum of start time and every duration of every note scheduled) this.metronome = false //metronome playing or not this.timerID = null //the timerID of the setInterval this.lookahead = 10 // How frequently to call scheduling function (in milliseconds) this.scheduleAheadTime = 0.1 // How far ahead to schedule audio (sec) this.seconds_per_beat = 60 / bpm //beats per second - tempo this.current_beat = 1 //current beat this.lastNoteDrawn = 3 this.bpm = bpm this.beats_per_measure = time_signature[0] this.beat_duration = time_signature[1] this.isPlaying = false this.beat_check = 0 this.loop = true } /** * returns a instance of rhythm to avoid creating more than one(a singleton) * @param {Number} bpm Speed of the rhythm in beats per minute * @param {Array} time_signature the number of notes per measure as an array [number_of_notes, type_of_notes] * @static */ static getRhythm(bpm = 80, time_signature = [4, 4]) { if (rhythm) return rhythm rhythm = new Rhythm(bpm, time_signature) return rhythm } /** * Schedual a note to be played at a specific time */ scheduleNote() { // push the note on the queue, even if we're not playing. if (this.data[this.next_note_to_schedule]) { this.scheduleNoteHelper(this.data[this.next_note_to_schedule]) this.next_note_to_schedule++ } else { this.next_note_to_schedule = 0 } } /** * Helps the SchedualNote check what kind of data is dealt with at the moment and handles it. * @param {Array/Note/Chord} data */ scheduleNoteHelper(data) { if (data instanceof Note || data instanceof Chord) { this.data_with_time.push({ sounds: [data], time: this.overall_time }) this.overall_time += 60 / this.bpm * note_durations[data.duration] * this.beats_per_measure } else if (isArray(data)) { let min_duration = note_durations[data.duration] data.forEach((note) =&gt; { min_duration = min_duration &lt; note_durations[note.duration] ? min_duration : note_durations[note.duration] }) this.data_with_time.push({ sounds: data, time: this.overall_time }) this.overall_time += 60 / this.bpm * min_duration * this.beats_per_measure } } playSounds() { for (const i of this.data_with_time[this.next_note].sounds) { // console.log(i.toString()) i.play() } } /** * Advances to the next note and updates the beat */ nextNote() { this.next_interval += this.seconds_per_beat * this.min_interval // Advance the beat number, wrap to zero this.beat_check += this.seconds_per_beat * this.min_interval if (this.prev_beat_time + this.seconds_per_beat &lt;= this.audioCtx.currentTime) { // console.log(this.prev_beat_time - this.start_time) if (this.metronome) this.metronome_sound.play() // console.log(audioCtx.currentTime - this.start_time) this.beat_check = 0 this.current_beat++ if (this.current_beat === this.beats_per_measure + 1) { this.current_beat = 1 } this.prev_beat_time += this.seconds_per_beat } if (this.data_with_time[this.next_note]) if (this.data_with_time[this.next_note].time &lt;= this.audioCtx.currentTime) { // console.log(this.data_with_time[this.next_note].time - this.start_time) this.playSounds() this.next_note++ } } draw() { let drawNote = rhythm.lastNoteDrawn rhythm.currentTime = rhythm.audioCtx.currentTime // We only need to draw if the note has moved. if (rhythm.lastNoteDrawn != drawNote) { rhythm.lastNoteDrawn = drawNote } // set up to draw again requestAnimationFrame(rhythm.draw) } getBeat() { return this.current_beat } toggle(index = 0) { rhythm = this this.isPlaying = !this.isPlaying if (this.isPlaying) { // start playing // check if context is in suspended state (autoplay policy) if (this.audioCtx.state === 'suspended') { this.audioCtx.resume() } this.start_time = this.audioCtx.currentTime this.overall_time = this.audioCtx.currentTime this.prev_beat_time = this.audioCtx.currentTime this.data_with_time.length = 0 this.next_note = index this.current_beat = 1 this.next_note_to_schedule = index scheduler() // kick off scheduling requestAnimationFrame(this.draw) // start the drawing loop. } else { clearTimeout(this.timerID) } } addNotes(data) { this.data = data } toggleMetronome() { if (rhythm) rhythm.metronome = !rhythm.metronome } updateBPM(bpm) { this.bpm = bpm this.seconds_per_beat = 60 / bpm if(this.isPlaying == true){ this.toggle() this.toggle() } } } × Search results Close "},"src_Sequence.js.html":{"id":"src_Sequence.js.html","title":"Source: src/Sequence.js","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Source: src/Sequence.js export class Sequence { constructor(measures = []) { this._measures = measures this._duration = 0 this._measures.forEach(meas =&gt; { this._duration += meas.duration }) } get measures() { return this._measures } set measures(measures) { this._measures = measures } /** * get the duration */ get duration() { return this._duration } /** * set the duration */ set duration(duration) { this._duration = duration } getData() { const data = new Array() for (const i of this.measures) for (const j of i.data) data.push(j) return data } length() { return this._measures.length; } addMeasure(measure) { this.measures.push(measure) } toString() { let string = \"Sequence: { \" for (let i of this.measures) string += i.toString() + ', ' string += '} ' return string } } × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Classes Classes Chord DiatonicScale Key Measure MusicalPattern Note Rhythm Rhythm × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Note-Art JS Musical Project By Sean Dvir A Work in progress!Music is a highly versatile art that originates in nature, and has been taken up by mankind as a way of expression and also as an art.Now, it's going to be taken up by machines as well.-This project aims to create a library that implements all of music theory(in all it's forms) in code, then create AI that will use that theory, math, and neuroscience to compose music in different styles and genres.It will also be used to create multiple tools for people to practice, learn, enjoy and compose. Installation# go to project folder npm install note-art “Everything is determined … by forces over which we have nocontrol. It is determined for the insects as well as for the star.Human beings, vegetables, or cosmic dust – we all dance to amysterious tune, intoned in the distance by an invisible piper.”– Albert Einstein × Search results Close "},"Chord.html":{"id":"Chord.html","title":"Class: Chord","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Class: Chord Chord represents a Chord. new Chord(root, third, fifth, note4(optional), duration) Parameters: Name Type Description root Note third Note fifth Note note4(optional) Note duration Source: src/Chord.js, line 8 Members &lt;static, readonly&gt; FIFTH :Number The index of the fifth. Type: Number Source: src/Chord.js, line 128 &lt;static, readonly&gt; NOTE4 :Number The index of the fourth note. Type: Number Source: src/Chord.js, line 135 &lt;static, readonly&gt; ROOT :Number The index of the root. Type: Number Source: src/Chord.js, line 114 &lt;static, readonly&gt; THIRD :Number The index of the third. Type: Number Source: src/Chord.js, line 121 &lt;readonly&gt; duration The duration of the chord as String Source: src/Chord.js, line 172 &lt;readonly&gt; fifth The fifth of the chord as Note Source: src/Chord.js, line 158 &lt;readonly&gt; note4 The fourth note of the chord as Note Source: src/Chord.js, line 165 &lt;readonly&gt; root The root of the chord as Note Source: src/Chord.js, line 142 &lt;readonly&gt; third The third of the chord as Note Source: src/Chord.js, line 151 Methods inversionFirst() Transforms the chord into its 1st-inversion. Source: src/Chord.js, line 206 inversionSecond() Transforms the chord into its 2st-inversion. Source: src/Chord.js, line 213 play() play all the notes in the chord as a harmony. Source: src/Chord.js, line 191 playMelody() play all the notes in the chord as a melody. Source: src/Chord.js, line 179 rootPosition() Transforms the chord into its root position. Source: src/Chord.js, line 199 toString() returns string of the name of the chord and all the notes it contains. Source: src/Chord.js, line 220 × Search results Close "},"DiatonicScale.html":{"id":"DiatonicScale.html","title":"Class: DiatonicScale","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Class: DiatonicScale DiatonicScale represents a Diatonic Scale(a scale that consists of 7 notes), new DiatonicScale(tonic, pattern) Parameters: Name Type Description tonic Note/String Root of the Scale pattern Array Intervals for the other notes(from the tonic). Source: src/Scale.js, line 7 Extends MusicalPattern Members notes returns array that contains all the notes in the pattern. Inherited From: MusicalPattern#notes Source: src/MusicalPattern.js, line 26 Methods getChord(chord) returns the x chord of the scale. Parameters: Name Type Description chord number Chord Number Source: src/Scale.js, line 25 getChords() returns array with all the chords in the scale. Source: src/Scale.js, line 32 getInterval(interval) returns the interval inside the patternfor example - if the pattern is C Major scale,than getInterval(1) wiil return D. Parameters: Name Type Description interval number Inherited From: MusicalPattern#getInterval Source: src/MusicalPattern.js, line 44 loadSound() load all the sound files of the notes in the pattern. Inherited From: MusicalPattern#loadSound Source: src/MusicalPattern.js, line 53 play() play all the notes in the pattern one after the other. Inherited From: MusicalPattern#play Source: src/MusicalPattern.js, line 60 toString() returns a string of all the notes in the pattern Inherited From: MusicalPattern#toString Source: src/MusicalPattern.js, line 32 × Search results Close "},"Key.html":{"id":"Key.html","title":"Class: Key","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Class: Key Key represents a Musical Key that is based on a specific Diatonic Scale., new Key() Source: src/Key.js, line 6 Extends DiatonicScale Methods getChord(chord) returns the x chord of the scale. Parameters: Name Type Description chord number Chord Number Inherited From: DiatonicScale#getChord Source: src/Scale.js, line 25 getChords() returns array with all the chords in the scale. Inherited From: DiatonicScale#getChords Source: src/Scale.js, line 32 × Search results Close "},"Measure.html":{"id":"Measure.html","title":"Class: Measure","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Class: Measure Measure Measure - represents a single measure as part of a musical piece. new Measure(data) Parameters: Name Type Description data Array An array which contains notes or chords Source: src/Measure.js, line 9 Members data Array of all the notes in the measure Source: src/Measure.js, line 23 data Assign new notes to measure Source: src/Measure.js, line 29 duration set the duration Source: src/Measure.js, line 50 duration get the duration Source: src/Measure.js, line 44 Methods addNotes(new_notes) Add data to the end of the measure Parameters: Name Type Description new_notes Note/Chord Source: src/Measure.js, line 67 getData() Returns a new array with the same notes. Source: src/Measure.js, line 35 mutate(index, new_notes) Change notes somewhere inside a measure Parameters: Name Type Description index Number The index where the notes will be changed new_notes Array/Note Notes to change to Source: src/Measure.js, line 58 × Search results Close "},"MusicalPattern.html":{"id":"MusicalPattern.html","title":"Class: MusicalPattern","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Class: MusicalPattern MusicalPattern Represents a musical pattern. new MusicalPattern(tonic, pattern) Parameters: Name Type Description tonic String/Note pattern Array Source: src/MusicalPattern.js, line 5 Members notes returns array that contains all the notes in the pattern. Source: src/MusicalPattern.js, line 26 Methods getInterval(interval) returns the interval inside the patternfor example - if the pattern is C Major scale,than getInterval(1) wiil return D. Parameters: Name Type Description interval number Source: src/MusicalPattern.js, line 44 loadSound() load all the sound files of the notes in the pattern. Source: src/MusicalPattern.js, line 53 play() play all the notes in the pattern one after the other. Source: src/MusicalPattern.js, line 60 toString() returns a string of all the notes in the pattern Source: src/MusicalPattern.js, line 32 × Search results Close "},"Note.html":{"id":"Note.html","title":"Class: Note","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Class: Note Note Represents a single musical note. new Note(note, octave, duration, instrument) Parameters: Name Type Default Description note String A Musical Note octave number 3 Note Octave duration String q Note duration instrument String Piano Piano/Guitar/etc... Source: src/Note.js, line 13 Members &lt;readonly&gt; duration :String get the duration of a note Type: String Source: src/Note.js, line 64 &lt;readonly&gt; frequency :Number get the frequancy of a note. Type: Number Source: src/Note.js, line 72 &lt;readonly&gt; note :String returns the note alphabet representation as a string. Type: String Source: src/Note.js, line 48 &lt;readonly&gt; octave :Number get octave of note. Type: Number Source: src/Note.js, line 56 Methods clone() returns a clone of the note(new instance). Source: src/Note.js, line 94 getInterval(interval) gets a number as interval and returns a new instance of a notewhich is constructed by the musical interval formula.for example, if the note is a 'C' in octave 3,calling the function with the number 4(which is a major third) will returna Note instance with the musical note 'E' in octave 3 with the same instrument. Parameters: Name Type Description interval number Musical Interval Source: src/Note.js, line 105 isEqual(note) Check if 2 notes are equal in letter and octave. Parameters: Name Type Description note Note Source: src/Note.js, line 135 play() Play the note. Source: src/Note.js, line 149 print() Returns string of the note fields formatted as an object. Source: src/Note.js, line 143 toString() Returns the note name and octave. Source: src/Note.js, line 128 Example 'C3' × Search results Close "},"Rhythm.html":{"id":"Rhythm.html","title":"Class: Rhythm","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Class: Rhythm Rhythm Creates a rhythm instance which holds bpm and time signature information. new Rhythm() Source: src/RhythmOld.js, line 24 Methods &lt;static&gt; getRhythm(bpm, time_signature) returns a instance of rhythm to avoid creating more than one(a singleton) Parameters: Name Type Default Description bpm Number 80 Speed of the rhythm in beats per minute time_signature Array the number of notes per measure as an array [number_of_notes, type_of_notes] Source: src/Rhythm.js, line 74 nextNote() Advances to the next note and updates the beat Source: src/Rhythm.js, line 124 scheduleNote() Schedual a note to be played at a specific time Source: src/Rhythm.js, line 83 scheduleNoteHelper(data) Helps the SchedualNote check what kind of data is dealt with at the moment and handles it. Parameters: Name Type Description data Array/Note/Chord Source: src/Rhythm.js, line 96 Class: Rhythm Rhythm Creates a rhythm instance which holds bpm and time signature information. new Rhythm(bpm, time_signature) Create a new instance of rhythm. Parameters: Name Type Description bpm Number Speed of the rhythm in beats per minute time_signature Array the number of notes per measure as an array [number_of_notes, type_of_notes] Source: src/Rhythm.js, line 22 Methods &lt;static&gt; getRhythm(bpm, time_signature) returns a instance of rhythm to avoid creating more than one(a singleton) Parameters: Name Type Default Description bpm Number 80 Speed of the rhythm in beats per minute time_signature Array the number of notes per measure as an array [number_of_notes, type_of_notes] Source: src/Rhythm.js, line 74 nextNote() Advances to the next note and updates the beat Source: src/Rhythm.js, line 124 scheduleNote() Schedual a note to be played at a specific time Source: src/Rhythm.js, line 83 scheduleNoteHelper(data) Helps the SchedualNote check what kind of data is dealt with at the moment and handles it. Parameters: Name Type Description data Array/Note/Chord Source: src/Rhythm.js, line 96 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
